# problem
>回文串就是正着读和反着读一样的字符串，如“abba”，"abcba"，最长回文子串是字符串的子串中最长的属于回文串的子串。如字符串"abbaabccba"的最长回文子串为"abccba".


# codes
```
#include<iostream>
#include<string>
using namespace std;

string longestPalindrome(string s){
    int n=s.size();
    bool dp[n][n];
    fill_n(&dp[0][0],n*n, false);
    int max_len=1;
    int start=0;
    for(int i=0;i<n;i++){
        for(int j=0;j<=i;j++){
            if(i-j<=2){
                dp[j][i]=(s[i]==s[j]);
            }else{
                dp[j][i]=(s[i]==s[j]&&dp[j+1][i-1]);
            }
            if(dp[j][i]&&max_len<(i-j+1)){
                max_len=i-j+1;
                start=j;
            }
        }
    }
    return s.substr(start,max_len);
    
}

int main(){
//    printf("hello world");
    string s;
    s=longestPalindrome("abbaabccba");
    cout<<s<<endl;
    return 0;
}

```

# analysis
>思路就不说了，关键是我是自己写出来的哈。
 ![image](../Images/longestSubstring.jpg)

# reference 
[动态规划算法求最长回文子串][1]

[1]: https://blog.csdn.net/shineboyxxb/article/details/52079360