## 信号量和互斥量
信号量：多线程同步使用的；一个线程完成某个动作后通过信号告诉别的线程，别的线程才可以执行某些动作；
    互斥量：多线程互斥使用的；一个线程占用某个资源，那么别的线程就无法访问，直到该线程离开，其他线程才可以访问该资源；

- 区别
1、互斥量用于线程的互斥，信号量用于线程的同步：
互斥：指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排他性。但是互斥无法限制访问者对资源的访问顺序，所以访问是无序的；

同步：指在互斥的基础上（多数情况），通过其他机制实现访问者对资源的有序访问。大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况指可以允许多个访问者同时访问资源。

2、互斥量值只能是0/1，信号量值可以为非负整数：
一个互斥量只能用于一个资源的互斥访问不能实现多个资源的多线程互斥问题；
        一个信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量时，也可以完成一个资源的互斥访问；

3、互斥量的加锁和解锁必须由同一线程分别对应使用；而信号量可以由一个线程释放，另外一个线程得到。

## A*搜索算法（A Star Search Algorithm）
- A*算法主要用于在二维平面上寻找两个点之间的最短路径。在从起始点到目标点的过程中有很多个状态空间，DFS和BFS没有任何启发策略所以穷举所有的状 态空间，不适合仅需对局部进行搜索的应用。启发式搜索的关键在于：当前节点在选择下一步节点的时候，可以通过一个启发函数进行选择，选择到达终点代价最小 的节点作为下一步节点。A*的启发函数构造为：

f(n)=g(n)+h(n)

f(n)是可选的下一个节点的代 价，g(n)表示从start点到n点的代价，h(n)表示从n点到end点的代价；但是h(n)是无法预知的，（如果将BFS看作一种A*的话，其 h(n)恒定为0，g(n)表示到起始点的层数）所以A*算法将当n点到end点的直线距离作为h(n)的估值，显然只能无限接近实际最优解。

- A*算法维护两张表OPEN和CLOSED，OPEN保存所有可探测但是还没有访问的节点，CLOSED保存素有已经访问的节点；启发函数就当前在 OPEN表中的节点进行排序，按照代价从低到高排列，每次选择代价最小的节点进行访问；当前访问的节点会根据簿记信息更新代价信息，并且将其直接连接的子 节点访问OPEN表中，最后将当前节点放入CLOSED表；A*算法开始于将start点放入OPEN表，结束于找到end点，或者OPEN表为 空，CLOSED表已经包含所有可访问节点。

- 程序实现中g(n)表示在抽象的状态空间中start点到n点的深度，h(n)表示在实际地图中n点所在地图位置到end点地图位置的直线距离.

## 红黑树
1） 每个节点要么是红的，要么是黑的
2） 根节点是黑的
3） 每个叶节点，即度为0的节点是黑色的
4） 如果一个节点是红色的，那么他的两个儿子就都是黑的
5） 对每个节点，从该节点到其所有叶子节点的所有路径包含相同数目的黑节点
6）如下为棵红黑树:（黑色节点用黑色表示，红色则以白色表示，叶子节点都会忽略不显示）

## C++ 容器

1. vector：  底层数据结构为数组 ，支持快速随机访问。
2. list：    底层数据结构为双向链表，支持快速增删。
3. deque：  底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问。
4. stack ：  底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
5. queue：   底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）
6. priority_queue： 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现
7. set：  底层数据结构为红黑树，有序，不重复。

8. multiset： 底层数据结构为红黑树，有序，可重复。 

9. map： 底层数据结构为红黑树，有序，不重复。

10. multimap： 底层数据结构为红黑树，有序，可重复。

11. hash_set： 底层数据结构为hash表，无序，不重复。

12. hash_multiset： 底层数据结构为hash表，无序，可重复 。

13. hash_map ： 底层数据结构为hash表，无序，不重复。

14. hash_multimap： 底层数据结构为hash表，无序，可重复。

C++ STL和几道经典的面试题. https://blog.csdn.net/dingyahui123/article/details/78644235

## 堆 栈
全局变量是程序是整个程序都需要用到的，单独分出一块存储区保存，该存储区存储的数据不清空
局部变量是函数退出时自动清空的，所以放在栈里做临时存储
new,malloc分配的内存需要自己手动申请自己手动释放
