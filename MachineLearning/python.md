## p1
is用于对比对象地址,如a=7;b=7;a is b；返回为True，代表的a,b这两个变量指向的对象（7这个整形变量）为同一个。a==b返回同样为True，代表a,b这两个变量指向变量的值都为7。而a=[1,2,3];b=[1,2,3]; a is b返回为False，因为此时a,b指向的对象不是同一个了（参见Python可变数据对象），而a==b依据为True,因为这个对象的值相等。

## p2
```
装饰器最大的作用就是对于我们已经写好的程序，我们可以抽离出一些雷同的代码组建多个特定功能的装饰器，这样我们就可以针对不同的需求去使用特定的装饰器，这时因为源码去除了大量泛化的内容而使得源码具有更加清晰的逻辑。
```

## *args与**args的区别
```
*args和**args适用于函数的参数不确定的时候。*args可以看做是多个变量组成的list。**args可以看做是个字典
```
## *args, **kwargs理解
```
*args 表示任何多个无名参数，它是一个tuple；**kwargs 表示关键字参数，它是一个dict。
```
python中*args, **kwargs理解. https://www.cnblogs.com/yflyaway/p/8442108.html

## 并发并行、同步异步、同步锁
```
并发：系统具有处理多个任务（动作）的能力

并行：系统具有同时处理多个任务（动作）的能力

同步：当进程执行到一个IO（等待外部数据）的时候，需要等待，等待即同步

异步：当进程执行到一个IO（等待外部数据）的时候，不需要等待，待数据接收成功后，再回来处理。

GIL:全局解释锁：无论你有多少个线程，你有多少个CPU，Python在执行的时候会淡定的在同一时刻只允许一个线程运行。（解释器层面保护进程安全）

GIL的作用：同一时刻，只有一个线程被CPU在执行，造成单线程运行结果，多核用不到。

垃圾回收机制：解释器的一个线程在进行垃圾回收。

CPU切换：io阻塞、cpu执行时间窗口等

线程都是竞争CPU资源来获得执行。

任务：io密集型（io交互多，CPU空闲时间多）、计算密集型（），time.sleep()等同于io操作

对于io密集型任务，python的多线程是有意义的，而计算密集型任务，python的多线程就不适用了，可以采用多进程。

同步锁：即将线程设置成串行，lock=threading.lock(),lock.acquire(),lock.release()
```
https://www.cnblogs.com/benchdog/p/9175574.html

## C++ 反射机制
```
C++并不支持反射机制，只能自己实现。

如果需要实现字字符串到函数到映射，一定要使用到函数指针。

简单实现反射机制，根据字符串来构造相应到类。主要有以下几点：

(1) 可以使用map保存字符从到函数指针到映射。

(2) 工厂类提供字符串与函数指针到注册关系。

(3) 工厂模式根据不同到字符串构造不同到类对象。
```