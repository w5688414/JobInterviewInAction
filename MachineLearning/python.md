## p1
is用于对比对象地址,如a=7;b=7;a is b；返回为True，代表的a,b这两个变量指向的对象（7这个整形变量）为同一个。a==b返回同样为True，代表a,b这两个变量指向变量的值都为7。而a=[1,2,3];b=[1,2,3]; a is b返回为False，因为此时a,b指向的对象不是同一个了（参见Python可变数据对象），而a==b依据为True,因为这个对象的值相等。

## p2
```
装饰器最大的作用就是对于我们已经写好的程序，我们可以抽离出一些雷同的代码组建多个特定功能的装饰器，这样我们就可以针对不同的需求去使用特定的装饰器，这时因为源码去除了大量泛化的内容而使得源码具有更加清晰的逻辑。
```

## *args与**args的区别
```
*args和**args适用于函数的参数不确定的时候。*args可以看做是多个变量组成的list。**args可以看做是个字典
```
## *args, **kwargs理解
```
*args 表示任何多个无名参数，它是一个tuple；**kwargs 表示关键字参数，它是一个dict。
```
python中*args, **kwargs理解. https://www.cnblogs.com/yflyaway/p/8442108.html

## 并发并行、同步异步、同步锁
```
并发：系统具有处理多个任务（动作）的能力

并行：系统具有同时处理多个任务（动作）的能力

同步：当进程执行到一个IO（等待外部数据）的时候，需要等待，等待即同步

异步：当进程执行到一个IO（等待外部数据）的时候，不需要等待，待数据接收成功后，再回来处理。

GIL:全局解释锁：无论你有多少个线程，你有多少个CPU，Python在执行的时候会淡定的在同一时刻只允许一个线程运行。（解释器层面保护进程安全）

GIL的作用：同一时刻，只有一个线程被CPU在执行，造成单线程运行结果，多核用不到。

垃圾回收机制：解释器的一个线程在进行垃圾回收。

CPU切换：io阻塞、cpu执行时间窗口等

线程都是竞争CPU资源来获得执行。

任务：io密集型（io交互多，CPU空闲时间多）、计算密集型（），time.sleep()等同于io操作

对于io密集型任务，python的多线程是有意义的，而计算密集型任务，python的多线程就不适用了，可以采用多进程。

同步锁：即将线程设置成串行，lock=threading.lock(),lock.acquire(),lock.release()
```
https://www.cnblogs.com/benchdog/p/9175574.html

## C++ 反射机制
```
C++并不支持反射机制，只能自己实现。

如果需要实现字字符串到函数到映射，一定要使用到函数指针。

简单实现反射机制，根据字符串来构造相应到类。主要有以下几点：

(1) 可以使用map保存字符从到函数指针到映射。

(2) 工厂类提供字符串与函数指针到注册关系。

(3) 工厂模式根据不同到字符串构造不同到类对象。
```
## 并发之协程
```
协程不同于线程，线程是抢占式的调度，而协程是协同式的调度，协程需要自己做调度。 
子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

协程优势是极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。用来执行协程多任务非常合适。

协程没有线程的安全问题。一个进程可以同时存在多个协程，但是只有一个协程是激活的，而且协程的激活和休眠又程序员通过编程来控制，而不是操作系统控制的。 
因为协程是一个线程中执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

yield 关键字

```
python并发之协程. https://blog.csdn.net/dutsoft/article/details/54729480
