# problem
你要在一个nxm的格子图上涂色，你每次可以选择一个未涂色的格子涂上你开始选定的那种颜色。同时为了美观，我们要求你涂色的格子不能相邻，也就是说，不能有公共边，现在问你，在采取最优策略的情况下，你最多能涂多少个格子？

给定格子图的长n和宽m。请返回最多能涂的格子数目。
测试样例：
```
1,2
```
```
返回：1
```

# codes
```
class Paint {
public:
    int getMost(int n, int m) {
        // write code here
        if(n*m%2==0){
            return n*m/2;
        }else{
            return n*m/2+1;
        }
    }
};
```

# analysis
1. 第一列，dp[i][0]，表示str1[0..i] str2[0]的最长公共子序列,一旦设定为1，dp[i+1,...M][0]全部为1.
2. 第一行，dp[0][j],与步骤1同理，如果str1[0]==str2[j],则令dp[0][j]=1,一旦dp[0][j]被设定为1，则令dp[0][j+1,...N]全部为1.
3. 其他位置，dp[i][j]来自以下三种情况，
3.1 可能是dp[i-1][j]的值，者表示str1[0..i-1]与str2[0...j]的最长公共子序列长度。
举例：
str1="A1BC2",str2="AB34C"
str1[0..3]为"A1BC"，str2为"AB34C"，这两部分最长公共子序列为"ABC"，即dp[3][4]为3
3.2 同理可知，dp[i][j]的值可能是dp[i][j-1].
3.3 如果str1[i]==str2[j]，这可能是dp[i-1][j-1]+1的值，
例如：
str1="ABCD",str2="ABCD"，str1[0..2]即"ABC"与str2[0...2]即"ABC"的最长公共子序列为"ABC"，即dp[2][2]=3;
最后一个字符都是"D"，所以dp[i][j]=dp[i-1][j-1]+1;

# reference
左成云课程